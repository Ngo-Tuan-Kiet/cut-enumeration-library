import networkx as nx
import math
import networkx as nx
import math
#from hao_orlin_diff import Partition, hao_orlin
from queue import PriorityQueue
from typing import Union, Tuple
from collections import namedtuple



type NodeSet = set
type Cut_value = Union[int, float]
type ST_partition = Tuple[NodeSet, NodeSet]

class Partition(namedtuple('PartitionBase', ['min_cut_value', 'details'])):
    __slots__ = ()

    def __str__(self):
        return f"Partition(min_cut_value={self.min_cut_value}, details={self.details})"

    def __repr__(self):
        return self.__str__()
def hao_orlin_directed(G, s):


    def initialize():
        """
        Initializes the graph for the push-relabel algorithm.
        """
        for v in G.nodes:
            G.nodes[v]['excess'] = 0
            G.nodes[v]['height'] = 0
        G.nodes[s]['excess'] = math.inf
        G.nodes[s]['height'] = len(G.nodes)
        
        for u, v in G.edges:
            G.edges[u, v]['preflow'] = 0
            G.edges[v, u]['preflow'] = 0

        for v in G.neighbors(s):
            push(s, v)

    def push(u, v):
        if u in X:
            send = G.edges[u, v]['capacity'] - G.edges[u, v]['preflow']
        else:
            send = min(G.nodes[u]['excess'], G.edges[u, v]['capacity'] - G.edges[u, v]['preflow'])
        G.nodes[u]['excess'] -= send
        G.nodes[v]['excess'] += send
        G.edges[u, v]['preflow'] += send
        G.edges[v, u]['preflow'] -= send
        
        if v != s and v != t and G.nodes[v]['height'] < k and v not in ACTIVE_NODES:
            ACTIVE_NODES.append(v)

    def relabel(u):
        nonlocal k
        nonlocal ACTIVE_NODES
        heights = []
        sorted_height_dict = get_sorted_node_heights()
        if(list(sorted_height_dict.values()).count(G.nodes[u]['height']) == 1):
            k = G.nodes[u]['height']
            if ACTIVE_NODES is not None:
                return
            for v in ACTIVE_NODES:
                if G.nodes[v]['height'] >= k:
                    ACTIVE_NODES.remove(v)
            return
        
        for v in G.neighbors(u):
            if G.edges[u, v]['capacity'] - G.edges[u, v]['preflow'] > 0:
                heights.append(G.nodes[v]['height'])
                min_height = min(heights)
        
        G.nodes[u]['height'] = min_height + 1

        if G.nodes[u]['height'] >= k:
            k = n - 1
            ACTIVE_NODES = [v for v in (V-{t}-{s}-{u}) if G.nodes[v]['excess'] > 0 and G.nodes[v]['height'] < k]

    def discharge(u):
        for v in G.neighbors(u):
            if G.nodes[u]['height'] == G.nodes[v]['height'] + 1 and G.edges[u, v]['capacity'] - G.edges[u, v]['preflow'] > 0 and v not in X and G.nodes[u]['excess'] > 0:
                push(u, v)
                return
        relabel(u)

    def get_sorted_node_heights():
        height_dict = {node: G.nodes[node]['height'] for node in G.nodes}
        sorted_height_dict = dict(sorted(height_dict.items(), key=lambda item: item[1]))
        return sorted_height_dict

    def get_cut_value(S):
        return sum(G.edges[u, v]['capacity'] for u in S for v in G.neighbors(u) if v not in S) if S != V else math.inf

    ACTIVE_NODES = []
    yeh_list = []
    V = set(G.nodes)
    X = {s}
    n = len(V)
    k = n - 1
    t = list(V - X)[0] if V != X else None
    t_prime = None
    min_cut_value = math.inf
    cuts = []

    initialize()

    while X != V:
        while ACTIVE_NODES:
            u = ACTIVE_NODES.pop()
            # print("K:")
            # print(k)
            discharge(u)
            # print("K after discharge:")
            # print(k)
        

            if G.nodes[u]['excess'] > 0 and G.nodes[u]['height'] < k and u not in ACTIVE_NODES:
                ACTIVE_NODES.append(u)

        print("jetzt mach ich das erste mal S:")
        print("k:")
        print(k)
        print("alle knoten und ihre höhen:")
        for node in G.nodes:
            print(f"Node: {node}, Height: {G.nodes[node]['height']}")
        S = set([i for i in V if G.nodes[i]['height'] >= k and i != t])
        print("cut:")
        print(S.copy(), V - S)
        current_cut_value = G.nodes[t]['excess'] # aber der cut ist dann falsch???
        current_cut_value = get_cut_value(S)
        min_cut_value = current_cut_value
        cut = (S.copy(), V - S)
        P = (X.copy(), {t})

        yeh_list.append(Partition(min_cut_value, {'P': P, 'cut': cut}))
        print(yeh_list)

        X.add(t)
        G.nodes[t]['height'] = n
        t_prime = min((v for v in (V - X)), key=lambda v: G.nodes[v]['height']) if V != X else None
        G.nodes[t]['excess'] = math.inf
        for v in G.neighbors(t):
            push(t, v)
        
        t = t_prime
        if t in ACTIVE_NODES:
            ACTIVE_NODES.remove(t)
        if t == None or G.nodes[t]['height'] >= k:
            k = n -1
            ACTIVE_NODES = [v for v in (V-{t}-{s}) if G.nodes[v]['excess'] > 0 and G.nodes[v]['height'] < k]

    return yeh_list

def hao_orlin(G, s):
    return hao_orlin_directed(G, s) if G.is_directed() else hao_orlin_directed(G.to_directed(), s)

if __name__ == '__main__':
    G = nx.Graph()
    G.add_edge('S', 'B', capacity=4)
    G.add_edge('S', 'D', capacity=8)
    G.add_edge('B', 'D', capacity=4)
    
    s = 'S'  # Startknoten für den Hao-Orlin-Algorithmus
    yeh_list = hao_orlin(G, s)
    print(yeh_list)
    
    # for partition in yeh_list:
    #     print("Min Cut Value:", partition.min_cut_value)
    #     print("P:", partition.details['P'])
    #     print("Cut:", partition.details['cut'])
