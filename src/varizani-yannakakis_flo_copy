import itertools
import networkx as nx
from networkx.algorithms.flow import edmonds_karp, minimum_cut
import matplotlib.pyplot as plt
import math
from queue import PriorityQueue


# Wrapper class for the cut data to be used in the priority queue
class Cut:
    def __init__(self, value, data):
        self.value = value
        self.partition = data['partition']
        self.partition_vector = data['partition_vector']
        self.mother = data['mother']
        self.leaf_set = data['leaf_set']

    def __lt__(self, other):
        return self.value < other.value


def cut_to_vector(G: nx.DiGraph, cut):
    """
    Given a graph G and a cut, return the vector representation of the cut.
    """
    vector = ''
    for node in G.nodes:
        if node in cut[0]:
            # Node is in S
            vector += '0'
        else:
            # Node is in T
            vector += '1'

    return vector


def get_all_leaf_vectors(n, internal_vector='') -> list[str]:
    """
    Given an integer n and an optional internal node vector, return all possible leaf vectors of length n.
    """
    return [internal_vector + ''.join(seq) for seq in itertools.product("01", repeat=n - len(internal_vector))]


def get_immediate_children(internal_vector, leaf_vector) -> list[str]:
    """
    Given the vector of an internal node and a leaf node, return the immediate children of the path from internal node to leaf node.
    """
    children = []
    leaf_binary = int(f'{leaf_vector}', 2)
    for i in range(len(leaf_vector) - len(internal_vector)):
        child = format(leaf_binary ^ 2 ** i, f'0{len(leaf_vector)}b')
        if i != 0:
            children.append(child[:-i])
        else:
            children.append(child)

    return children


def global_min_cut(G: nx.DiGraph):
    """
    Given a graph G, return the global min cut of the graph.
    """
    nodes = list(G.nodes)
    # Temporary fix for the case where the graph has only 1 node
    if len(nodes) == 1:
        return (math.inf, (set(nodes), set()))
    fixed_node = nodes[0]
    min_s_cut = (math.inf, ())
    min_t_cut = (math.inf, ())

    for node in nodes[1:]:
        #if fixed_node != 'T' and node != 'S':
            if min_s_cut[0] > minimum_cut(G, fixed_node, node, flow_func=edmonds_karp)[0]:
                min_s_cut = minimum_cut(G, fixed_node, node,flow_func=edmonds_karp)
        #if fixed_node != 'S' and node != 'T':
            if min_t_cut[0] > minimum_cut(G, node, fixed_node,flow_func=edmonds_karp)[0]:
                min_t_cut = minimum_cut(G, node, fixed_node,flow_func=edmonds_karp)

    return min_s_cut if min_s_cut[0] <= min_t_cut[0] else min_t_cut

def collapsed_G_min_cut(G_collapsed):
    nodes=list(G_collapsed.nodes)

    if len(nodes) == 1:
        return (math.inf, (set(nodes), set()))
    
    fixed_node = nodes[0]
    min_s_cut = (math.inf, ())
    min_t_cut = (math.inf, ())

    if "S" in nodes and "T" in nodes:
        S_node="S"
        T_node="T"
        min_s_cut=minimum_cut(G_collapsed, S_node, T_node,flow_func=edmonds_karp)
        min_t_cut=minimum_cut(G_collapsed, T_node, S_node,flow_func=edmonds_karp)
        return min_s_cut if min_s_cut[0] <= min_t_cut[0] else min_t_cut
    elif "S" in nodes and not "T" in nodes:
        S_node="S"
        for node in nodes:
            if node != "S":
                if min_s_cut[0] > minimum_cut(G_collapsed, S_node, node, flow_func=edmonds_karp)[0]:
                    min_s_cut = minimum_cut(G_collapsed, S_node, node,flow_func=edmonds_karp)
                if min_t_cut[0] > minimum_cut(G_collapsed, node, S_node,flow_func=edmonds_karp)[0]:
                    min_t_cut = minimum_cut(G_collapsed, node, S_node,flow_func=edmonds_karp)
        return min_s_cut if min_s_cut[0] <= min_t_cut[0] else min_t_cut

    elif "T" in nodes and not "S" in nodes:
        T_node="T"
        for node in nodes:
            if node != "T":
                if min_s_cut[0] > minimum_cut(G_collapsed, node, T_node, flow_func=edmonds_karp)[0]:
                    min_s_cut = minimum_cut(G_collapsed, node, T_node,flow_func=edmonds_karp)
                if min_t_cut[0] > minimum_cut(G_collapsed, T_node, node,flow_func=edmonds_karp)[0]:
                    min_t_cut = minimum_cut(G_collapsed, T_node, node,flow_func=edmonds_karp)
        return min_s_cut if min_s_cut[0] <= min_t_cut[0] else min_t_cut




def collapse_graph(G: nx.DiGraph, cut_vector):
    """
    Given a directed graph G and a cut, represented by its binary vector, return the collapsed graph.
    """
    # Separate the nodes into sets S and T
    nodes = list(G.nodes)
    S = []
    T = []
    for i in range(len(cut_vector)):
        if cut_vector[i] == '0':
            S.append(nodes[i])
        elif cut_vector[i] == '1':
            T.append(nodes[i])

    # Collapse the nodes in S and T
    G_collapse = G.copy()
    if len(S) > 0:
        G_collapse.add_node('S')
    if len(T) > 0: #was wenn wir das nicht haben? dann wird t einfach beliebig gew√§hlt?
        G_collapse.add_node('T')
    for node in S:
        G_collapse = nx.contracted_nodes(G_collapse, 'S', node, self_loops=False) #wie sind denn die capacities nach contracted_nodes? sicher dass er die nicht schon addiert?
    for node in T:
        G_collapse = nx.contracted_nodes(G_collapse, 'T', node, self_loops=False)

    # Set capacities to 0 for edges connected to S or T                       
    for edge in G_collapse.edges:
        if edge[0] == 'S' or edge[1] == 'S' or edge[0] == 'T' or edge[1] == 'T':
            G_collapse[edge[0]][edge[1]]['capacity'] = 0

    # Sum the capacities of the edges coming out of S and T
    for node in S:
        for neighbor in G.neighbors(node):
            if neighbor not in S and neighbor not in T:
                G_collapse['S'][neighbor]['capacity'] += G[node][neighbor]['capacity']
                G_collapse[neighbor]['S']['capacity'] += G[node][neighbor]['capacity']
            if neighbor in T:
                G_collapse['S']['T']['capacity'] += G[node][neighbor]['capacity']
    for node in T:
        for neighbor in G.neighbors(node):
            if neighbor not in T and neighbor not in S:
                G_collapse['T'][neighbor]['capacity'] += G[node][neighbor]['capacity']
                G_collapse[neighbor]['T']['capacity'] += G[node][neighbor]['capacity']
            if neighbor in S:
                G_collapse['T']['S']['capacity'] += G[node][neighbor]['capacity']
    
    return G_collapse


def get_original_partition(partition, cut_vector):
    """
    Given a partition of nodes including S and T nodes and the cut vector used to collapse, return the original partition of nodes.
    """
    original_partition = partition
    # Go through the cut vector and assign each node to its original side
    for i in range(len(cut_vector)):
        if cut_vector[i] == '0':
            original_partition[0].add(i+1)
        elif cut_vector[i] == '1':
            original_partition[1].add(i+1)
    
    # Remove the S and T nodes from the partition
    for side in original_partition:
        if 'S' in side:
            side.remove('S')
        if 'T' in side:
            side.remove('T')
    return original_partition


def varizani_yannakakis(G: nx.DiGraph):
    """
    Varizani-Yannakakis algorithm for enumerating all min-cuts of a graph G.
    """
    enumerated_cuts = []

    # Calculate the global min cut of the graph and get necessary data
    min_cut_value, min_cut_partition = global_min_cut(G) #min-value und partition in int
    min_cut_vector = cut_to_vector(G, min_cut_partition) #partition in 01
    leaf_set = get_all_leaf_vectors(G.number_of_nodes()) #P(v) set
    
    # Initialize priority queue with the min cut value, it's node partition, the mother vector and all possible leaf vectors
    queue = PriorityQueue()
    queue.put(Cut(min_cut_value, {'partition': min_cut_partition, 'partition_vector': min_cut_vector, 'mother': '', 'leaf_set': leaf_set}))

    while not queue.empty():

        # Get the current cut with the smallest value
        current_cut: Cut = queue.get()

        # Add the current cut to the list of enumerated cuts
        enumerated_cuts.append((current_cut.value, current_cut.partition))

        # Get the immediate children of the current cut
        immediate_children = get_immediate_children(current_cut.mother, current_cut.partition_vector)

        for child_vector in immediate_children:
            # Collapse the graph based on the child vector
            collapsed_graph = collapse_graph(G, child_vector)
            # Calculate the min cut for the child and get the necessary data
            child_min_value, child_min_partition = collapsed_G_min_cut(collapsed_graph)
            child_min_partition = get_original_partition(child_min_partition, child_vector)
            child_min_vector = cut_to_vector(G, child_min_partition)
            child_leaf_set = get_all_leaf_vectors(G.number_of_nodes(), child_vector)

            # Add the min cut of the child to the queue
            queue.put(Cut(child_min_value, {'partition': child_min_partition, 'partition_vector': child_min_vector, 'mother': child_vector, 'leaf_set': child_leaf_set}))

    # Return the list of enumerated cuts
    return enumerated_cuts


if __name__ == '__main__':
    G = nx.DiGraph()
    G.add_edge(1, 2, capacity=10)
    G.add_edge(2, 1, capacity=10)

    G.add_edge(2, 3, capacity=10)
    G.add_edge(3, 2, capacity=10)

    G.add_edge(2, 4, capacity=1)
    G.add_edge(4, 2, capacity=1)

    G2 = nx.DiGraph()
    G2.add_edge(1, 2, capacity=1)
    G2.add_edge(2, 3, capacity=2)
    G2.add_edge(3, 1, capacity=3)

    for edge in G.edges():
        print(edge)

    #print(varizani_yannakakis(G))

    # G = collapse_graph(G, '001')
    # pos = nx.spring_layout(G)
    # edges = {edge: G[edge[0]][edge[1]]['capacity'] for edge in G.edges}
    # nx.draw(G, pos, with_labels=True)
    # nx.draw_networkx_edge_labels(G, pos, edge_labels=edges)
    # plt.show()
    #collapse_graph(G, "00")

def print_graph_info(G):
    print("Nodes in the graph:")
    for node in G.nodes():
        print(node)
    
    print("\nEdges with capacities:")
    for edge in G.edges(data=True):
        # edge is a tuple like (u, v, {'capacity': c})
        u, v, data = edge
        print(f"Edge from {u} to {v} with capacity {data['capacity']}")


G_collapsed=collapse_graph(G, "010")
print(print_graph_info(G_collapsed))
print(G_collapsed.nodes)
print(collapsed_G_min_cut(G_collapsed))

# fig, ax = plt.subplots(1, 2, figsize=(12, 6))
# plt.suptitle('Graphen Visualisierung')

# ax[0].set_title('Original Graph')
# nx.draw(G, with_labels=True, node_color='skyblue', ax=ax[0], node_size=800)

# ax[1].set_title('Kollabierter Graph')
# nx.draw(G_collapsed, with_labels=True, node_color='lightgreen', ax=ax[1], node_size=800)

# plt.show()