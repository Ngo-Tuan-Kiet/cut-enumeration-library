import networkx as nx
import math

def hao_orlin_directed(G, s):
    global k  # Declare k as global here

    def initialize():
        """
        Initializes the graph for the push-relabel algorithm.
        """
        for v in G.nodes:
            G.nodes[v]['excess'] = 0
            G.nodes[v]['height'] = 0
        G.nodes[s]['excess'] = math.inf
        G.nodes[s]['height'] = len(G.nodes)
        
        for u, v in G.edges:
            G.edges[u, v]['preflow'] = 0
            G.edges[v, u]['preflow'] = 0

        for v in G.neighbors(s):
            push(s, v)

    def push(u, v):
        """
        Pushes flow from u to v.
        """
        global k  # Ensure k is declared as global in push
        send = min(G.nodes[u]['excess'], G.edges[u, v]['capacity'] - G.edges[u, v]['preflow'])
        G.nodes[u]['excess'] -= send
        G.nodes[v]['excess'] += send
        G.edges[u, v]['preflow'] += send
        G.edges[v, u]['preflow'] -= send

        if v != s and v != t and G.nodes[v]['excess'] > 0 and G.nodes[v]['height'] <= k and v not in ACTIVE_NODES:
            ACTIVE_NODES.append(v)

        if u != s and u != t and G.nodes[u]['excess'] > 0 and G.nodes[u]['height'] <= k and u not in ACTIVE_NODES:
            ACTIVE_NODES.append(u)

    def relabel(u):
        """
        Relabels the height of node u.
        """
        heights = []
        for v in G.neighbors(u):
            if G.edges[u, v]['capacity'] - G.edges[u, v]['preflow'] > 0:
                heights.append(G.nodes[v]['height'])
                print("heights_list")
                print(heights)
        if heights:
            min_height = min(heights)
            G.nodes[u]['height'] = min_height + 1

    def discharge(u):
        """
        Discharges the excess flow from node u.
        """
        global k  # Ensure k is declared as global in discharge
        while G.nodes[u]['excess'] > 0:
            print("height of u:")
            print(G.nodes[u]['height'])
            if G.nodes[u]['height'] >= k:
                break
            for v in G.neighbors(u):
                if G.nodes[u]['height'] == G.nodes[v]['height'] + 1 and G.edges[u, v]['capacity'] - G.edges[u, v]['preflow'] > 0:
                    print("wir pushen aus u")
                    push(u, v)
                    print("exzess u nach push")
                    print(G.nodes[u]['excess'])
                    if G.nodes[u]['excess'] == 0:
                        break
            else:
                height_list = [G.nodes[node]['height'] for node in G.nodes if node != t]
                if height_list.count(G.nodes[u]['height']) == 1:
                    print("wir setzen k auf die unique height")
                    k = G.nodes[u]['height']
                    print("k")
                    print(k)
                else:
                    print("wir relabeln u")
                    relabel(u)
                    print("relabelte_height_of_u")
                    print(G.nodes[u]['height'])
                    if G.nodes[u]['height'] >= k:
                        #k = n - 1
                        G.nodes[u]['height'] = n-1
                        print("k, if k was set to n-1")
                        print(k)

    def get_cut_value(S):
        """
        Returns the cut value of the graph.
        """
        return sum(G.edges[u, v]['capacity'] for u in S for v in G.neighbors(u) if v not in S) if S != V else math.inf

    ACTIVE_NODES = []
    V = set(G.nodes)
    X = {s}
    n = len(V)
    k = n - 1  # Initialize k correctly here
    t = list(V - X)[0]
    t_prime = None
    min_cut_value = math.inf
    cut = set()

    initialize()
    

    while X != V:
        print("t")
        print(t)
        while ACTIVE_NODES:
            print(ACTIVE_NODES)  # TODO: ACTIVE NODES may be empty at some point
            u = ACTIVE_NODES.pop(0)
            print("u:")
            print(u)
            print("k:")
            print(k)
            discharge(u)

        S = set([i for i in V if G.nodes[i]['height'] >= k])
        cut = S
        print("cut:")
        print(cut, V - cut)
        print("k zum Zeitpunkt des cuts:")
        print(k)



        current_cut_value = get_cut_value(S)
        if current_cut_value < min_cut_value:
            min_cut_value = current_cut_value
            cut = S

        X.add(t)
        G.nodes[t]['height'] = n
        G.nodes[t]['excess'] = math.inf
        for v in G.neighbors(t):
            push(t, v) #hier tun wir dann ja auch was in active nodes, wollen wir das hier?
        print("Active nodes:")
        print(ACTIVE_NODES)
        t_prime = min((v for v in V if v not in X), key=lambda v: G.nodes[v]['height']) if V != X else None
        t = t_prime
        if t is not None and G.nodes[t]['height'] >= k:
            k = n - 1

    cut = (cut, V - cut)
    return (min_cut_value, cut)

def hao_orlin(G, s):
    return hao_orlin_directed(G, s) if G.is_directed() else hao_orlin_directed(G.to_directed(), s)

if __name__ == '__main__':
    G = nx.Graph()
    G.add_edge("a", "b", capacity=6)
    G.add_edge("a", "c", capacity=2)
    G.add_edge("c", "d", capacity=1)
    G.add_edge("c", "e", capacity=7)
    G.add_edge("c", "f", capacity=9)
    G.add_edge("a", "d", capacity=3)

    G2 = nx.Graph()
    G2.add_edge(1, 2, capacity=6)
    G2.add_edge(1, 3, capacity=2)
    G2.add_edge(3, 4, capacity=1)
    G2.add_edge(3, 5, capacity=7)
    G2.add_edge(3, 6, capacity=9)
    G2.add_edge(1, 4, capacity=3)

    min_cut = hao_orlin(G, 'a')
    print(min_cut)